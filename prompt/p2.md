// shaders.ts - 修改后的着色器，实现各种炫酷效果
export const vertexShaderSource = `
  attribute vec2 a_position;
  attribute vec2 a_texCoord;
  varying vec2 v_texCoord;
  
  void main() {
    gl_Position = vec4(a_position, 0.0, 1.0);
    v_texCoord = a_texCoord;
  }
`;

export const getFragmentShader = (effect: string): string => {
  const baseShader = `
    precision mediump float;
    uniform sampler2D u_texture;
    varying vec2 v_texCoord;
    uniform float u_time;
    uniform vec2 u_resolution;
    
    // 辅助函数：HSV到RGB转换
    vec3 hsv2rgb(vec3 c) {
      vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
      vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
      return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
    }
    
    // 辅助函数：获取亮度
    float luminance(vec3 color) {
      return dot(color, vec3(0.299, 0.587, 0.114));
    }
    
    // 辅助函数：噪声函数
    float random(vec2 st) {
      return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);
    }
  `;

  switch (effect) {
    case 'mirror':
      // 水平镜像效果 - 左半边镜像到右半边
      return baseShader + `
        void main() {
          vec2 coord = v_texCoord;
          if (coord.x > 0.5) {
            coord.x = 1.0 - coord.x; // 右半边使用左半边的镜像
          }
          gl_FragColor = texture2D(u_texture, coord);
        }
      `;

    case 'vmirror':
      // 垂直镜像效果 - 上半边镜像到下半边
      return baseShader + `
        void main() {
          vec2 coord = v_texCoord;
          if (coord.y > 0.5) {
            coord.y = 1.0 - coord.y; // 下半边使用上半边的镜像
          }
          gl_FragColor = texture2D(u_texture, coord);
        }
      `;
      
    case 'convex':
      // 凸镜效果 - 中心放大
      return baseShader + `
        void main() {
          vec2 center = vec2(0.5, 0.5);
          vec2 coord = v_texCoord - center;
          float dist = length(coord);
          
          float factor = 1.0 - smoothstep(0.0, 0.6, dist) * 0.3;
          vec2 newCoord = center + coord * factor;
          
          gl_FragColor = texture2D(u_texture, newCoord);
        }
      `;
      
    case 'concave':
      // 凹镜效果 - 中心缩小
      return baseShader + `
        void main() {
          vec2 center = vec2(0.5, 0.5);
          vec2 coord = v_texCoord - center;
          float dist = length(coord);
          
          float factor = 1.0 + smoothstep(0.0, 0.4, dist) * 0.6;
          vec2 newCoord = center + coord * factor;
          
          if (newCoord.x < 0.0 || newCoord.x > 1.0 || newCoord.y < 0.0 || newCoord.y > 1.0) {
            gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
          } else {
            gl_FragColor = texture2D(u_texture, newCoord);
          }
        }
      `;
      
    case 'wave':
      // 波浪效果
      return baseShader + `
        void main() {
          vec2 coord = v_texCoord;
          
          coord.x += sin(coord.y * 15.0 + u_time * 3.0) * 0.02;
          coord.y += cos(coord.x * 15.0 + u_time * 3.0) * 0.02;
          
          coord = clamp(coord, 0.0, 1.0);
          gl_FragColor = texture2D(u_texture, coord);
        }
      `;
      
    case 'swirl':
      // 漩涡效果
      return baseShader + `
        void main() {
          vec2 center = vec2(0.5, 0.5);
          vec2 coord = v_texCoord - center;
          float dist = length(coord);
          
          float angle = atan(coord.y, coord.x) + dist * 5.0 + u_time * 1.0;
          vec2 newCoord = center + vec2(cos(angle), sin(angle)) * dist;
          
          gl_FragColor = texture2D(u_texture, newCoord);
        }
      `;
      
    case 'fisheye':
      // 鱼眼效果
      return baseShader + `
        void main() {
          vec2 center = vec2(0.5, 0.5);
          vec2 coord = v_texCoord - center;
          float dist = length(coord);
          
          float factor = 1.0 / (1.0 + dist * 1.0);
          factor = mix(1.0, factor, smoothstep(0.0, 0.5, dist));
          
          vec2 newCoord = center + coord * factor;
          gl_FragColor = texture2D(u_texture, newCoord);
        }
      `;

    case 'kaleidoscope':
      // 万花筒效果
      return baseShader + `
        void main() {
          vec2 center = vec2(0.5, 0.5);
          vec2 coord = v_texCoord - center;
          
          float angle = atan(coord.y, coord.x);
          float radius = length(coord);
          
          // 创建6个对称扇形
          angle = mod(angle, 3.14159 / 3.0);
          if (mod(floor(atan(coord.y, coord.x) / (3.14159 / 3.0)), 2.0) == 1.0) {
            angle = 3.14159 / 3.0 - angle;
          }
          
          vec2 newCoord = center + vec2(cos(angle), sin(angle)) * radius;
          gl_FragColor = texture2D(u_texture, newCoord);
        }
      `;

    case 'rgbshift':
      // RGB分离效果
      return baseShader + `
        void main() {
          vec2 coord = v_texCoord;
          float offset = 0.01 * sin(u_time * 2.0);
          
          float r = texture2D(u_texture, coord + vec2(offset, 0.0)).r;
          float g = texture2D(u_texture, coord).g;
          float b = texture2D(u_texture, coord - vec2(offset, 0.0)).b;
          
          gl_FragColor = vec4(r, g, b, 1.0);
        }
      `;

    case 'pixelate':
      // 像素风效果
      return baseShader + `
        void main() {
          float pixelSize = 20.0 + sin(u_time) * 10.0;
          vec2 coord = floor(v_texCoord * pixelSize) / pixelSize;
          
          vec3 color = texture2D(u_texture, coord).rgb;
          
          // 增加对比度和饱和度
          color = pow(color, vec3(1.2));
          float gray = dot(color, vec3(0.299, 0.587, 0.114));
          color = mix(vec3(gray), color, 1.5);
          
          gl_FragColor = vec4(color, 1.0);
        }
      `;

    case 'oilpainting':
      // 油画效果
      return baseShader + `
        void main() {
          vec2 coord = v_texCoord;
          vec3 color = vec3(0.0);
          
          // 多次采样模拟油画笔触
          for (int i = 0; i < 8; i++) {
            float angle = float(i) * 0.785398; // 45度间隔
            vec2 offset = vec2(cos(angle), sin(angle)) * 0.01;
            color += texture2D(u_texture, coord + offset).rgb;
          }
          
          color /= 8.0;
          
          // 增强饱和度和对比度
          color = pow(color, vec3(0.8));
          float lum = luminance(color);
          color = mix(vec3(lum), color, 1.8);
          
          gl_FragColor = vec4(color, 1.0);
        }
      `;

    case 'neon':
      // 霓虹边缘效果
      return baseShader + `
        void main() {
          vec2 coord = v_texCoord;
          vec3 color = texture2D(u_texture, coord).rgb;
          
          // 边缘检测
          vec2 texelSize = 1.0 / u_resolution;
          vec3 edge = vec3(0.0);
          
          for (int x = -1; x <= 1; x++) {
            for (int y = -1; y <= 1; y++) {
              vec2 sampleCoord = coord + vec2(float(x), float(y)) * texelSize * 2.0;
              vec3 sampleColor = texture2D(u_texture, sampleCoord).rgb;
              edge += abs(color - sampleColor);
            }
          }
          
          edge /= 9.0;
          float edgeStrength = length(edge);
          
          // 创建霓虹色彩
          vec3 neonColor = hsv2rgb(vec3(u_time * 0.1 + edgeStrength, 1.0, 1.0));
          
          // 混合原色和霓虹边缘
          color = mix(color * 0.3, neonColor, edgeStrength * 3.0);
          
          gl_FragColor = vec4(color, 1.0);
        }
      `;

    case 'rainbow':
      // 彩虹扭曲效果
      return baseShader + `
        void main() {
          vec2 center = vec2(0.5, 0.5);
          vec2 coord = v_texCoord - center;
          
          float dist = length(coord);
          float angle = atan(coord.y, coord.x);
          
          // 彩虹扭曲
          angle += sin(dist * 10.0 + u_time * 2.0) * 0.5;
          coord = vec2(cos(angle), sin(angle)) * dist + center;
          
          vec3 color = texture2D(u_texture, coord).rgb;
          
          // 添加彩虹色调
          float hue = dist * 2.0 + u_time * 0.5;
          vec3 rainbow = hsv2rgb(vec3(hue, 0.8, 1.0));
          
          // 混合原色和彩虹色
          color = mix(color, color * rainbow, 0.4);
          
          gl_FragColor = vec4(color, 1.0);
        }
      `;
      
    default:
      // 正常效果
      return baseShader + `
        void main() {
          gl_FragColor = texture2D(u_texture, v_texCoord);
        }
      `;
  }
};

----
// utils/mirror-renderer.ts
import { vertexShaderSource, getFragmentShader } from "./shaders";
import { setupWebGL, setupVertexAttributes, cleanupWebGL } from "./webgl-utils";

export interface RenderConfig {
  gl: WebGLRenderingContext;
  canvas: any;
  cameraContext: any;
  effect: string;
  onError?: (error: string) => void;
  frameSkip?: number;
}

export interface RenderStatus {
  isRendering: boolean;
  currentEffect: string;
  hasResources: boolean;
  frameCount?: number;
  fps?: number;
}

export class MirrorRenderer {
  private gl: WebGLRenderingContext;
  private canvas: any;
  private cameraContext: any;
  private program: WebGLProgram | null = null;
  private texture: WebGLTexture | null = null;
  private buffer: WebGLBuffer | null = null;
  private isRendering: boolean = false;
  private startTime: number = 0;
  private currentEffect: string = "normal";
  private onError?: (error: string) => void;
  private frameListener: any = null;

  // 性能控制
  private frameSkip: number = 2;
  private frameCounter: number = 0;

  // 性能统计
  private frameCount: number = 0;
  private lastFpsTime: number = 0;
  private currentFps: number = 0;

  constructor(config: RenderConfig) {
    this.gl = config.gl;
    this.canvas = config.canvas;
    this.cameraContext = config.cameraContext;
    this.currentEffect = config.effect;
    this.onError = config.onError;
    this.frameSkip = config.frameSkip || 2;
  }

  /**
   * 初始化WebGL资源
   */
  private initWebGLResources(): boolean {
    try {
      this.cleanup();

      const fragmentShaderSource = getFragmentShader(this.currentEffect);
      const result = setupWebGL(
        this.gl,
        vertexShaderSource,
        fragmentShaderSource
      );

      if (!result.program || !result.texture || !result.buffer) {
        this.handleError("Failed to setup WebGL resources");
        return false;
      }

      this.program = result.program;
      this.texture = result.texture;
      this.buffer = result.buffer;

      return true;
    } catch (error) {
      this.handleError(`WebGL initialization error: ${error}`);
      return false;
    }
  }

  /**
   * 开始渲染
   */
  start(): boolean {
    if (this.isRendering) {
      console.log("Already rendering, stopping previous render");
      this.stop();
    }

    if (!this.initWebGLResources()) {
      return false;
    }

    this.isRendering = true;
    this.startTime = Date.now();
    this.frameCount = 0;
    this.frameCounter = 0;
    this.lastFpsTime = this.startTime;

    this.startCameraFrameListener();

    console.log("MirrorRenderer started with onCameraFrame");
    return true;
  }

  /**
   * 启动相机帧监听
   */
  private startCameraFrameListener(): void {
    if (!this.cameraContext) {
      this.handleError("Camera context not available");
      return;
    }

    this.frameListener = this.cameraContext.onCameraFrame((frame: any) => {
      if (!this.isRendering) return;

      this.frameCounter++;
      if (this.frameCounter % this.frameSkip !== 0) {
        return;
      }

      try {
        this.processFrameData(frame);
      } catch (error) {
        console.error("Frame processing error:", error);
      }
    });

    if (this.frameListener && typeof this.frameListener.start === "function") {
      this.frameListener.start();
    }
  }

  /**
   * 处理相机帧数据
   */
  private processFrameData(frame: any): void {
    if (!this.gl || !this.program || !this.texture || !this.buffer) {
      return;
    }

    const currentTime = Date.now();
    this.updateFpsStats(currentTime);

    const imgData = new Uint8Array(frame.data);
    const processedData = this.applyEffect(imgData, frame.width, frame.height);

    this.renderFrameData(processedData, frame.width, frame.height);
  }

  /**
   * 应用效果处理
   */
  private applyEffect(
    imgData: Uint8Array,
    width: number,
    height: number
  ): Uint8Array {
    const processedData = new Uint8Array(imgData.length);

    switch (this.currentEffect) {
      case "redRemove":
        for (let i = 0; i < imgData.length; i += 4) {
          const pixel = {
            r: imgData[i],
            g: imgData[i + 1],
            b: imgData[i + 2],
            a: imgData[i + 3],
          };

          if (
            pixel.r >= 100 &&
            pixel.r >= pixel.g * 2 &&
            pixel.r >= pixel.b * 2
          ) {
            processedData[i] = 0;
            processedData[i + 1] = 0;
            processedData[i + 2] = 0;
            processedData[i + 3] = 0;
          } else {
            processedData[i] = imgData[i];
            processedData[i + 1] = imgData[i + 1];
            processedData[i + 2] = imgData[i + 2];
            processedData[i + 3] = imgData[i + 3];
          }
        }
        break;

      case "mirror":
        // 镜像效果 - 水平翻转
        for (let y = 0; y < height; y++) {
          for (let x = 0; x < width; x++) {
            const srcIndex = (y * width + x) * 4;
            const dstIndex = (y * width + (width - 1 - x)) * 4;

            processedData[dstIndex] = imgData[srcIndex];
            processedData[dstIndex + 1] = imgData[srcIndex + 1];
            processedData[dstIndex + 2] = imgData[srcIndex + 2];
            processedData[dstIndex + 3] = imgData[srcIndex + 3];
          }
        }
        break;

      default:
        processedData.set(imgData);
        break;
    }

    return processedData;
  }

  /**
   * 渲染帧数据
   */
  private renderFrameData(
    data: Uint8Array,
    width: number,
    height: number
  ): void {
    if (!this.gl || !this.program || !this.texture || !this.buffer) {
      return;
    }

    const gl = this.gl;
    const canvas = this.canvas;
    const shaderTime = (Date.now() - this.startTime) / 1000;

    gl.useProgram(this.program);
    setupVertexAttributes(gl, this.program, this.buffer);

    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, this.texture);

    gl.texImage2D(
      gl.TEXTURE_2D,
      0,
      gl.RGBA,
      width,
      height,
      0,
      gl.RGBA,
      gl.UNSIGNED_BYTE,
      data
    );

    this.setUniforms(shaderTime, width, height, canvas.width, canvas.height);

    gl.clearColor(0, 0, 0, 1);
    gl.clear(gl.COLOR_BUFFER_BIT);
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
  }

  /**
   * 设置uniform变量
   */
  private setUniforms(
    time: number,
    textureWidth?: number,
    textureHeight?: number,
    canvasWidth?: number,
    canvasHeight?: number
  ): void {
    if (!this.gl || !this.program) return;

    const gl = this.gl;

    const textureLocation = gl.getUniformLocation(this.program, "u_texture");
    if (textureLocation) {
      gl.uniform1i(textureLocation, 0);
    }

    const timeLocation = gl.getUniformLocation(this.program, "u_time");
    if (timeLocation) {
      gl.uniform1f(timeLocation, time);
    }

    const resolutionLocation = gl.getUniformLocation(
      this.program,
      "u_resolution"
    );
    if (resolutionLocation) {
      const finalCanvasWidth = canvasWidth || this.canvas.width;
      const finalCanvasHeight = canvasHeight || this.canvas.height;
      gl.uniform2f(resolutionLocation, finalCanvasWidth, finalCanvasHeight);
    }

    const textureResolutionLocation = gl.getUniformLocation(
      this.program,
      "u_textureResolution"
    );
    if (textureResolutionLocation && textureWidth && textureHeight) {
      gl.uniform2f(textureResolutionLocation, textureWidth, textureHeight);
    }

    const aspectLocation = gl.getUniformLocation(this.program, "u_aspect");
    if (aspectLocation) {
      const aspect =
        (canvasWidth || this.canvas.width) /
        (canvasHeight || this.canvas.height);
      gl.uniform1f(aspectLocation, aspect);
    }
  }

  /**
   * 停止渲染
   */
  stop(): void {
    this.isRendering = false;

    if (this.frameListener && typeof this.frameListener.stop === "function") {
      this.frameListener.stop();
    }
    this.frameListener = null;

    this.cleanup();
  }

  /**
   * 切换效果
   */
  changeEffect(effect: string): boolean {
    if (effect === this.currentEffect) {
      return true;
    }

    const wasRendering = this.isRendering;
    this.currentEffect = effect;

    if (wasRendering) {
      this.initWebGLResources();
    }

    return true;
  }

  /**
   * 更新配置
   */
  updateConfig(config: Partial<RenderConfig>): void {
    if (config.frameSkip !== undefined) {
      this.frameSkip = config.frameSkip;
    }
    if (config.onError !== undefined) {
      this.onError = config.onError;
    }
  }

  /**
   * 更新FPS统计
   */
  private updateFpsStats(currentTime: number): void {
    this.frameCount++;
    if (currentTime - this.lastFpsTime >= 1000) {
      this.currentFps = Math.round(
        (this.frameCount * 1000) / (currentTime - this.lastFpsTime)
      );
      this.frameCount = 0;
      this.lastFpsTime = currentTime;
    }
  }

  /**
   * 清理WebGL资源
   */
  private cleanup(): void {
    if (this.gl && (this.program || this.texture || this.buffer)) {
      cleanupWebGL(this.gl, this.program, this.texture, this.buffer);
      this.program = null;
      this.texture = null;
      this.buffer = null;
    }
  }

  /**
   * 错误处理
   */
  private handleError(message: string): void {
    console.error("MirrorRenderer:", message);
    if (this.onError) {
      this.onError(message);
    }
  }

  /**
   * 获取当前状态
   */
  getStatus(): RenderStatus {
    return {
      isRendering: this.isRendering,
      currentEffect: this.currentEffect,
      hasResources: !!(this.program && this.texture && this.buffer),
      frameCount: this.frameCount,
      fps: this.currentFps,
    };
  }

  /**
   * 暂停渲染（保留资源）
   */
  pause(): void {
    this.isRendering = false;
    if (this.frameListener && typeof this.frameListener.stop === "function") {
      this.frameListener.stop();
    }
  }

  /**
   * 恢复渲染
   */
  resume(): boolean {
    if (this.isRendering) {
      return true;
    }

    if (!this.program || !this.texture || !this.buffer) {
      return this.start();
    }

    this.isRendering = true;
    this.startCameraFrameListener();
    return true;
  }

  /**
   * 销毁渲染器
   */
  destroy(): void {
    this.stop();
    this.gl = null as any;
    this.canvas = null;
    this.cameraContext = null;
    this.onError = undefined;
  }
}
---
// webgl-utils.ts
export const setupWebGL = (gl: WebGLRenderingContext, vertexShaderSource: string, fragmentShaderSource: string) => {
  // 创建着色器
  const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
  const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
  
  if (!vertexShader || !fragmentShader) {
    console.error('Failed to create shaders');
    return { program: null, texture: null, buffer: null };
  }

  // 创建程序
  const program = createProgram(gl, vertexShader, fragmentShader);
  if (!program) {
    console.error('Failed to create program');
    return { program: null, texture: null, buffer: null };
  }

  // 设置顶点数据
  const positions = new Float32Array([
    -1, -1,  0, 1,
     1, -1,  1, 1,
    -1,  1,  0, 0,
     1,  1,  1, 0,
  ]);

  const buffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
  gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);

  // 创建纹理
  const texture = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, texture);
  
  // 设置纹理参数
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);

  // 清理着色器（程序链接后就不需要了）
  gl.deleteShader(vertexShader);
  gl.deleteShader(fragmentShader);

  return { program, texture, buffer };
};

// 添加清理函数
export const cleanupWebGL = (gl: WebGLRenderingContext, program: WebGLProgram | null, texture: WebGLTexture | null, buffer: WebGLBuffer | null) => {
  if (program) {
    gl.deleteProgram(program);
  }
  if (texture) {
    gl.deleteTexture(texture);
  }
  if (buffer) {
    gl.deleteBuffer(buffer);
  }
};

// 设置顶点属性的独立函数
export const setupVertexAttributes = (gl: WebGLRenderingContext, program: WebGLProgram, buffer: WebGLBuffer) => {
  gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
  
  const positionLocation = gl.getAttribLocation(program, 'a_position');
  const texCoordLocation = gl.getAttribLocation(program, 'a_texCoord');

  gl.enableVertexAttribArray(positionLocation);
  gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 16, 0);

  gl.enableVertexAttribArray(texCoordLocation);
  gl.vertexAttribPointer(texCoordLocation, 2, gl.FLOAT, false, 16, 8);
};

const createShader = (gl: WebGLRenderingContext, type: number, source: string): WebGLShader | null => {
  const shader = gl.createShader(type);
  if (!shader) {
    console.error('Failed to create shader');
    return null;
  }

  gl.shaderSource(shader, source);
  gl.compileShader(shader);

  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
    console.error('Shader compile error:', gl.getShaderInfoLog(shader));
    gl.deleteShader(shader);
    return null;
  }

  return shader;
};

const createProgram = (gl: WebGLRenderingContext, vertexShader: WebGLShader, fragmentShader: WebGLShader): WebGLProgram | null => {
  const program = gl.createProgram();
  if (!program) {
    console.error('Failed to create program');
    return null;
  }

  gl.attachShader(program, vertexShader);
  gl.attachShader(program, fragmentShader);
  gl.linkProgram(program);

  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
    console.error('Program link error:', gl.getProgramInfoLog(program));
    gl.deleteProgram(program);
    return null;
  }

  return program;
};

---

性能优化，保持原来效果情况下优化。